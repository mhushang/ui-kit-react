// Generated by dts-bundle-generator v7.1.0

import React from 'react';
import { ChangeEvent, InputHTMLAttributes, KeyboardEvent, ReactElement, ReactNode } from 'react';

export declare enum BUTTON_TYPE {
	default = "default",
	primaryOrange = "primary-orange",
	primaryGrey = "primary-grey",
	primaryGreen = "primary-green",
	primaryRed = "primary-red",
	noBorder = "no-border",
	link = "link",
	hoverUnderline = "hoverUnderline",
	underline = "underline"
}
export interface IButtonProps {
	ariaLabel: string | null;
	text?: string | React.ReactElement | null;
	theme?: BUTTON_TYPE.default | BUTTON_TYPE.primaryOrange | BUTTON_TYPE.primaryGrey | BUTTON_TYPE.primaryGreen | BUTTON_TYPE.primaryRed | BUTTON_TYPE.noBorder | BUTTON_TYPE.link | BUTTON_TYPE.hoverUnderline | BUTTON_TYPE.underline;
	error?: boolean;
	disabled?: boolean;
	className?: string;
	leftIcon?: React.ReactElement;
	centralIcon?: React.ReactElement;
	rightIcon?: React.ReactElement;
	loading?: boolean;
	handleClick?: (...args: any) => void;
	id?: string;
	name?: string;
	tabIndex?: number;
	submit?: boolean;
}
export declare const Button: React.FC<IButtonProps>;
export declare enum INPUT_TYPE {
	text = "text",
	number = "number",
	password = "password"
}
export interface IInput {
	readOnly?: boolean;
	placeholder: string | null;
	error: boolean;
	errorText: string | null;
	disabled: boolean;
	bigLabel: string | null;
	smallLabel: string | null;
	maxLength: number;
	width: number;
	value: string | number;
	type: INPUT_TYPE.text | INPUT_TYPE.number | INPUT_TYPE.password;
	icon: ReactElement;
	firstIconButton: IIconButtonProps;
	secondIconButton: IIconButtonProps;
	handleChange: (e: ChangeEvent<HTMLInputElement>) => void;
	handleBlur: (e: ChangeEvent<HTMLInputElement>) => void;
	handleKeyPress: (e: KeyboardEvent<HTMLInputElement>) => void;
	name: string;
	styles?: object;
	id: string;
}
export interface IIconButtonProps {
	icon: ReactElement;
	ariaLabel: string | null;
	disabled?: boolean;
	handleClick: (...args: any) => void;
}
export interface IInputProps extends Partial<IInput> {
	ariaLabel: string | null;
	nativeProps?: InputHTMLAttributes<HTMLInputElement>;
}
export declare const Input: React.FC<IInputProps>;
export interface IToggle {
	disabled?: boolean;
	error?: boolean;
	defaultValue?: boolean;
	value?: boolean;
	label?: string | null;
	handleClick?: (...args: any) => void;
	handleChange?: (value: boolean) => void;
}
export interface IToggleProps extends IToggle {
	ariaLabel: string | null;
}
export declare const Toggle: React.FC<IToggleProps>;
export interface ITextProps {
	children: ReactNode;
	display?: boolean;
	size?: number;
	bold?: boolean;
	underline?: boolean;
	uppercase?: boolean;
	color?: `#${string}`;
	spacing?: number;
	className?: string;
}
export declare const Text: React.FC<ITextProps>;
export interface IExpandedProps {
	header: React.ReactNode;
	content: React.ReactNode;
	className?: string;
	label?: React.ReactElement | string | null;
	ariaLabel: string | null;
}
export declare const Expanded: React.FC<IExpandedProps>;
export declare enum LOADER_COLOR {
	orange = "orange",
	white = "white"
}
export interface ILoaderProps {
	color?: LOADER_COLOR.orange | LOADER_COLOR.white;
}
export declare const Loader: React.FC<ILoaderProps>;
export declare enum PLACEMENT_TYPE {
	top = "top",
	bottom = "bottom",
	right = "right",
	left = "left",
	topStart = "top-start",
	topEnd = "top-end",
	bottomStart = "bottom-start",
	bottomEnd = "bottom-end",
	rightStart = "right-start",
	rightEnd = "right-end",
	leftStart = "left-start",
	leftEnd = "left-end",
	auto = "auto",
	autoStart = "auto-start",
	autoEnd = "auto-end"
}
export declare enum TRIGGER_TYPE {
	click = "click",
	hover = "hover"
}
export interface IPopoverProps {
	placement: PLACEMENT_TYPE.top | PLACEMENT_TYPE.right | PLACEMENT_TYPE.bottom | PLACEMENT_TYPE.left | PLACEMENT_TYPE.topStart | PLACEMENT_TYPE.topEnd | PLACEMENT_TYPE.leftStart | PLACEMENT_TYPE.leftEnd | PLACEMENT_TYPE.rightStart | PLACEMENT_TYPE.rightEnd | PLACEMENT_TYPE.bottomStart | PLACEMENT_TYPE.bottomEnd | PLACEMENT_TYPE.auto | PLACEMENT_TYPE.autoStart | PLACEMENT_TYPE.autoEnd;
	trigger?: TRIGGER_TYPE.click | TRIGGER_TYPE.hover;
	referenceNode: React.ReactElement;
	children: React.ReactNode;
	arrow?: boolean;
	wrapperClassName?: string;
	isOpen?: boolean;
	onChange?: (isOpen: boolean) => void;
	fullRefWidth?: boolean;
}
export declare const Popover: React.FC<IPopoverProps>;
export interface IModalProps {
	isOpen: boolean;
	children: React.ReactElement;
	closable?: boolean;
	escClose?: boolean;
	width?: number;
	height?: number;
	onClose?: () => void;
	loading?: boolean;
}
export declare const Modal: React.FC<IModalProps>;
export interface ITab {
	name: string;
	ariaLabel: string | null;
	key: string;
	notificationCount?: number;
	onClick?: (item: ITab) => void;
	disabled?: boolean;
}
export interface ITabsProps {
	items: Array<ITab>;
	activeKey?: string;
	divider?: boolean;
	onChange?: (item: ITab) => void;
}
export declare const Tabs: React.FC<ITabsProps>;
export declare enum CHECKBOX_VALUE {
	indeterminate = "indeterminate"
}
export interface ICheckbox {
	disabled: boolean;
	value: boolean | CHECKBOX_VALUE.indeterminate;
	label: string | React.ReactNode;
	className: string;
	onChange: (isChecked: boolean, event?: React.ChangeEvent<HTMLInputElement>) => void;
	error: boolean;
	name: string;
}
export interface ICheckboxProps extends Partial<ICheckbox> {
	children?: React.ReactNode;
	ariaLabel: string | null;
}
export declare const Checkbox: React.FC<ICheckboxProps>;
export declare enum SORTER_TYPE {
	asc = "asc",
	desc = "desc"
}
export declare enum COLUMN_ALIGN_TYPE {
	start = "start",
	center = "center",
	end = "end"
}
export declare enum TABLE_TYPE {
	regular = "regular",
	minimal = "minimal"
}
export interface IColumn extends Record<string, any> {
	key?: string;
}
export type IScroll = {
	x?: number;
	y: number;
};
export type OrderType = SORTER_TYPE.asc | SORTER_TYPE.desc | null;
export interface IColumnType<T extends IColumn> {
	key: string;
	title: string | React.ReactNode;
	width: number;
	render?: (item: T, column: IColumnType<T>) => React.ReactNode;
	onSort?: (key: string, order: OrderType) => void;
	align?: COLUMN_ALIGN_TYPE.start | COLUMN_ALIGN_TYPE.center | COLUMN_ALIGN_TYPE.end;
}
export interface ITableProps<T extends IColumn> {
	data: T[];
	columns: IColumnType<T>[];
	loading?: boolean;
	hasSelected?: boolean;
	scroll?: IScroll;
	notFoundContent: React.ReactNode | string;
	rtl?: boolean;
	className?: string;
	leftSideSelectedNode?: React.ReactNode;
	rightSideSelectedNode?: React.ReactNode;
	onChange?: (item: T) => void;
	type?: TABLE_TYPE.minimal | TABLE_TYPE.regular;
}
export interface ISorterProps {
	activeSort: string | null | undefined;
	onClick: () => void;
	children: React.ReactElement;
}
export declare function Table<T extends IColumn>({ data, columns, hasSelected, scroll, loading, notFoundContent, rtl, className, leftSideSelectedNode, rightSideSelectedNode, onChange, type, }: ITableProps<T>): JSX.Element;
declare const PAGINATION_LIMITS: number[];
declare const PAGINATION_DEFAULT_LOCALIZATION: {
	go_to: string;
	go_to_pages: string;
	page: string;
	pages: string;
	next_page: string;
	previous_page: string;
	next_5_pages: string;
	of: string;
	limit: string;
	previous_5_pages: string;
};
export interface IPaginationProps {
	totalItems: number;
	onChange: (page: number, limit: number) => void;
	ariaLabel: string | null;
	currentPage?: number;
	currentLimit?: (typeof PAGINATION_LIMITS)[number];
	rangeDropDown?: boolean;
	rangeDropDownPlacement?: PLACEMENT_TYPE.bottom | PLACEMENT_TYPE.top;
	rangeLabel?: boolean;
	goToPage?: boolean;
	localization?: PaginationLocalizationType;
}
export type PaginationLocalizationType = {
	[K in keyof typeof PAGINATION_DEFAULT_LOCALIZATION]?: string;
};
export declare const Pagination: React.FC<IPaginationProps>;
export declare enum OVERLAY_PLACEMENT_TYPE {
	top = "top",
	right = "right",
	bottom = "bottom",
	left = "left"
}
export interface IOverlayProps {
	isOpen: boolean;
	children: React.ReactNode;
	closable?: boolean;
	escClose?: boolean;
	width?: number | string;
	height?: number | string;
	onClose?: () => void;
	placement?: OVERLAY_PLACEMENT_TYPE.top | OVERLAY_PLACEMENT_TYPE.right | OVERLAY_PLACEMENT_TYPE.bottom | OVERLAY_PLACEMENT_TYPE.left;
	footer?: React.ReactNode;
	className?: string;
}
export declare const Overlay: React.FC<IOverlayProps>;
export declare const useToaster: () => IToasterContext;
export declare enum TOASTER_PLACEMENT_TYPE {
	top = "top",
	bottom = "bottom",
	topLeft = "top-left",
	topRight = "top-right",
	bottomLeft = "bottom-left",
	bottomRight = "bottom-right"
}
export declare enum TOASTER_TYPE {
	warning = "warning",
	info = "info",
	error = "error",
	success = "success"
}
export type TToasterType = TOASTER_TYPE.success | TOASTER_TYPE.info | TOASTER_TYPE.warning | TOASTER_TYPE.error;
export interface IToasterProviderProps {
	children: React.ReactNode;
	placement: TOASTER_PLACEMENT_TYPE.top | TOASTER_PLACEMENT_TYPE.topLeft | TOASTER_PLACEMENT_TYPE.topRight | TOASTER_PLACEMENT_TYPE.bottom | TOASTER_PLACEMENT_TYPE.bottomLeft | TOASTER_PLACEMENT_TYPE.bottomRight;
}
export interface IToaster {
	text: string | React.ReactNode;
	type: TToasterType;
	id?: string;
	duration?: number;
	autoClose?: boolean;
	icon?: React.ReactNode | boolean;
}
export interface IToasterContext {
	toaster: (toast: IToaster) => string;
	closeToaster: (id: string) => void;
}
export interface IToasterProps extends IToaster {
	onClose?: () => void;
}
export declare const ToasterProvider: React.FC<IToasterProviderProps>;
declare const DROPDOWN_DEFAULT_LOCALIZATION: {
	selected: string;
	search: string;
	clear_selected: string;
	no_data: string;
};
export interface IOption {
	value: string;
	key: string;
	label?: JSX.Element | string;
	disabled?: boolean;
}
export interface IOptionProps extends IOption {
	multiple?: boolean;
	isSelected?: boolean | CHECKBOX_VALUE.indeterminate;
	handleChange?: (isChecked: boolean, checkBoxValue: string) => void;
}
export type TOptionsTreeItemId = string | null;
export interface IOptionsTreeItem extends IOption {
	parent_id: TOptionsTreeItemId;
	id: string;
}
export interface IOptionTreeProps {
	options: IOptionsTreeItem[];
	selectedItems: string[];
	multiple?: boolean;
	isSelected?: boolean;
	handleChange?: (isChecked: boolean, checkBoxValue: string) => void;
	disabled?: boolean;
}
export interface IDropDownProps {
	options: IOption[] | IOptionsTreeItem[];
	searchIsActive?: boolean;
	showClearSelectedButton?: boolean;
	showSelectedTags?: boolean;
	onClearSelected?: () => void;
	value?: string[] | string;
	multiple?: boolean;
	tree?: boolean;
	disabled?: boolean;
	onChange: (selected: Array<string> | string) => void;
	placeholder: string | null;
	error?: boolean;
	localization?: DropDownLocalizationType;
	ariaLabel: string | null;
	errorText?: string;
	isLoading?: boolean;
}
export type DropDownLocalizationType = {
	[K in keyof typeof DROPDOWN_DEFAULT_LOCALIZATION]?: string;
};
export declare const DropDown: React.FC<IDropDownProps>;
export declare const Option: React.FC<IOptionProps>;
export declare const OptionTree: React.FC<IOptionTreeProps>;
export declare enum STATUS_COLOR {
	none = "none",
	gray = "gray",
	red = "red",
	blue = "blue",
	green = "green",
	orange = "orange",
	violet = "violet"
}
export interface IStatusProps {
	children: JSX.Element | string;
	color?: keyof typeof STATUS_COLOR;
	disabled?: boolean;
	highlightBorder?: boolean;
	className?: string;
	leftIcon?: ReactElement;
	rightIcon?: ReactElement;
	isClickable?: boolean;
	onClick?: () => void;
	styles?: object;
}
export declare const Status: React.FC<IStatusProps>;
export interface IDropDownStatusProps extends Partial<IStatusProps> {
	color?: keyof typeof STATUS_COLOR;
	options?: IDropDownStatusOption[];
	value?: string | number;
	onChange?: (selectedOption: IDropDownStatusOption) => void;
}
export interface IDropDownStatusOption {
	value: string | number;
	label: string;
}
export declare const DropDownStatus: React.FC<IDropDownStatusProps>;
export declare enum MESSAGE_TYPE {
	warning = "warning",
	info = "info",
	error = "error",
	success = "success"
}
export type TMessageType = MESSAGE_TYPE.success | MESSAGE_TYPE.info | MESSAGE_TYPE.warning | MESSAGE_TYPE.error;
export interface IMessageProps {
	isOpen?: boolean;
	text: string | React.ReactNode;
	type: TMessageType;
	icon?: React.ReactNode | boolean;
	backgroundColor?: `#${string}`;
	className?: string;
}
export declare const Message: React.FC<IMessageProps>;
export interface IDropDownButtonProps {
	options: IDropDownButtonOption[];
	value?: string | number;
	onChange?: (selectedOption: IDropDownButtonOption) => void;
	leftIcon?: ReactElement;
	placeholder?: JSX.Element | string;
	disabled?: boolean;
	className?: string;
	label?: JSX.Element | string;
	labelPrefix?: JSX.Element | string;
}
export interface IDropDownButtonOption {
	value: string | number;
	key: string;
	label: JSX.Element | string;
	disabled?: boolean;
}
export declare const DropDownButton: React.FC<IDropDownButtonProps>;
export declare const generateUUID: () => string;
export interface ICountDown {
	countdown: JSX.Element;
	secondsLeft: number;
	isStopped: boolean;
	resetTo: (resetSeconds: number) => void;
}
export declare const useCountdown: (seconds: number) => ICountDown;
export declare const useDebounce: <T>(value: T, delay?: number) => T;

export {};
